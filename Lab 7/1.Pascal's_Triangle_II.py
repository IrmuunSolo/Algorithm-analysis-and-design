class Solution:
    def getRow(self, n: int):
        row = [1]
        for i in range(n):
            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]
        return row
    
# getRow нэртэй функц, n нь мөрийн индекс (0-оос эхэлдэг)
# n = 3 бол бид Pascal-ийн дөрөв дэх мөрийшщг гаргана.
# Төрөл тодорхойлолт (n: int)

# массивт утга олгох row = [1], Энэ нь динамик суурь нөхцөл (base case) юм.

# for i in range(n):
# ➡ Бид n удаа давтаж дараагийн мөрүүдийг тооцно.
# → range(n) нь 0-оос n-1 хүртэл тоо үүсгэнэ.
# → Жишээ нь n = 3 бол 3 удаа давтана: i = 0, 1, 2.

# 5. row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]

# a) range(len(row)-1)
# → row-ийн элемент бүрийн хосын тоогоор давтана.
# → len(row)-1 нь дараалсан 2 элемент хослох боломжийн тоо юм.

# b) row[j] + row[j+1]
# → Өмнөх мөрийн j болон j+1 индексийн элементүүдийн нийлбэр — энэ нь дараагийн мөрийн дундах утга болдог.

# c) [row[j] + row[j+1] for j in range(len(row)-1)]
# → Энэ нь list comprehension ашиглан дараагийн мөрийн дундах бүх утгуудыг нэг мөрөөр тооцдог.
# → Жишээ:
# Хэрвээ row = [1, 2, 1] байвал:
# [row[j] + row[j+1] for j in range(2)] → [1+2, 2+1] → [3, 3]

# d) [1] + ... + [1]
# [1] + [3,3] + [1] → [1,3,3,1]